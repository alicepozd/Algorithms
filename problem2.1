#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

class Graph {
public:
    Graph(int VortexCount) {
        nextdoors.resize(VortexCount);
        VortexNum = VortexCount;
    }

    void AddVortex() {
        std::vector<std::pair<int, int>> NewVortex(0);
        nextdoors.push_back(NewVortex);
        VortexNum++;
    }

    void AddEdge(int from, int to, int w) {
        nextdoors[from].push_back(std::pair<int, int>(to, w));
    }

    bool HasEdge(int from, int to) {
        for (int i = 0; i < nextdoors[from - 1].size(); i++) {
            if (nextdoors[from - 1][i].first == to - 1) {
                return true;
            }
        }
        return false;
    }

    const std::vector<std::pair<int, int>>& GetNextVertexes(int from) const {
        return nextdoors[from];
    }

    int VertexCount() const {
        return VortexNum;
    }

    void sortedges() {
        for (int i = 0; i < nextdoors.size(); i++) {
            sort(nextdoors[i].begin(), nextdoors[i].end());
        }
    }

    void Print() const {
        std::cout << "(";
        for (int i = 0; i < nextdoors.size(); i++) {
            std::cout << "-";
            for (int j = 0; j < nextdoors[i].size(); j++){
                std::cout << "(" << nextdoors[i][j].first << ", " << nextdoors[i][j].second << ") ";
            }
        }
        std::cout << ")";
    }
private:
    std::vector<std::vector<std::pair<int, int>>> nextdoors;
    int VortexNum;
};

int dijkstra(Graph& graph, int x, int y){
    int inf = INT32_MAX;
    std::vector<int> value (graph.VertexCount(), inf);
    std::set<std::pair<int, int>> s;
    s.insert(std::pair<int, int>(0, x));
    value[x] = 0;
    while (!s.empty()) {
        std::pair<int, int> now = (*s.begin());
        for (auto i : graph.GetNextVertexes(now.second)){
            if (s.count(std::pair<int, int>(value[i.first], i.first)) and value[i.first] > now.first + i.second){
                s.erase(s.find(std::pair<int, int>(value[i.first], i.first)));
                s.insert(std::pair<int, int>(now.first + i.second, i.first));
                value[i.first] = now.first + i.second;
            }
            else if (value[i.first] > now.first + i.second) {
                s.insert(std::pair<int, int>(now.first + i.second, i.first));
                value[i.first] = now.first + i.second;
            }
        }
        s.erase(s.begin());
    }
    return  value[y];
}

void MakeGraph(Graph& graph, int m, int a, int b){
    for (int i = 0; i < m; i++) {
        long long temp = (static_cast<long long>(i) * i + 1) % m;
        if (temp != i) {
            graph.AddEdge(i, temp, b);
        }
        graph.AddEdge(i, (i + 1) % m, a);
    }
}

int main() {
    int a, b, m, x, y;
    std::cin >> a >> b >> m >> x >> y;
    Graph graph(m);
    MakeGraph(graph, m, a, b);
    int n = dijkstra(graph, x, y);
    std::cout << n;
    return 0;
}